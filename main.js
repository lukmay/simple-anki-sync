/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, please visit the GitHub repository of this plugin
*/

'use strict';

var obsidian = require('obsidian');

const ANKI_CONNECT_URL = 'http://127.0.0.1:8765';
const MANAGED_NOTE_TAG = 'obsidian_simple_anki_sync_created';
async function sendRequest(action, params = {}) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.addEventListener('error', () => reject(new Error('Failed to issue request to AnkiConnect. Is Anki running?')));
        xhr.addEventListener('load', () => {
            try {
                const resp = JSON.parse(xhr.responseText);
                if (resp.error) {
                    console.error('AnkiConnect Error:', resp.error);
                    reject(new Error(`AnkiConnect error: ${resp.error}`));
                }
                else {
                    resolve(resp.result);
                }
            }
            catch (err) {
                console.error('Failed to parse AnkiConnect response:', err);
                reject(new Error('Failed to parse AnkiConnect response.'));
            }
        });
        xhr.open('POST', ANKI_CONNECT_URL);
        xhr.send(JSON.stringify({ action, version: 6, params }));
    });
}
class AnkiService {
    constructor(app) {
        this.app = app;
    }
    async verifyConnection() {
        try {
            await sendRequest('requestPermission');
            const decks = await sendRequest('deckNames');
            return Array.isArray(decks);
        }
        catch (err) {
            new obsidian.Notice('AnkiConnect connection failed. Is Anki open with AnkiConnect installed?');
            console.error('verifyConnection error:', err);
            return false;
        }
    }
    async fetchDecks() {
        try {
            return await sendRequest('deckNames');
        }
        catch (err) {
            new obsidian.Notice('Failed to retrieve deck list from Anki.');
            console.error(err);
            return [];
        }
    }
    async createDeck(name) {
        try {
            await sendRequest('createDeck', { deck: name });
        }
        catch (err) {
            if (err instanceof Error && err.message.includes('deck already exists'))
                return;
            new obsidian.Notice(`Could not create deck "${name}".`);
            console.error(err);
        }
    }
    async addNote(deck, model, fields, tags = []) {
        try {
            const allTags = [...tags, MANAGED_NOTE_TAG];
            const result = await sendRequest('addNote', {
                note: { deckName: deck, modelName: model, fields, tags: allTags },
            });
            if (typeof result === 'number')
                return result;
            new obsidian.Notice('AnkiConnect did not return a valid note ID.');
            return null;
        }
        catch (err) {
            new obsidian.Notice(`Failed to add note: ${err instanceof Error ? err.message : err}`);
            console.error(err);
            return null;
        }
    }
    async updateNote(noteId, fields) {
        try {
            await sendRequest('updateNoteFields', {
                note: { id: noteId, fields },
            });
            // Ensure our tag persists
            const infos = await this.fetchNotesInfo([noteId]);
            if (infos[0] && !infos[0].tags.includes(MANAGED_NOTE_TAG)) {
                await sendRequest('updateNoteTags', {
                    note: noteId,
                    tags: [...infos[0].tags, MANAGED_NOTE_TAG],
                });
            }
        }
        catch (err) {
            new obsidian.Notice(`Failed to update note ${noteId}: ${err}`);
            console.error(err);
        }
    }
    async deleteNotes(ids) {
        if (!ids.length)
            return;
        try {
            await sendRequest('deleteNotes', { notes: ids });
            new obsidian.Notice(`Deleted ${ids.length} note(s) from Anki.`);
        }
        catch (err) {
            new obsidian.Notice(`Could not delete notes: ${err}`);
            console.error(err);
        }
    }
    async fetchNotesInfo(ids) {
        if (!ids.length)
            return [];
        try {
            return await sendRequest('notesInfo', { notes: ids });
        }
        catch (err) {
            new obsidian.Notice('Failed to fetch note info from Anki.');
            console.error(err);
            return [];
        }
    }
    async findManagedNotes() {
        try {
            const result = await sendRequest('findNotes', { query: `tag:${MANAGED_NOTE_TAG}` });
            return Array.isArray(result) ? result : [];
        }
        catch (err) {
            new obsidian.Notice('Could not find managed notes in Anki.');
            console.error(err);
            return [];
        }
    }
    async changeDeck(cardIds, deckName) {
        try {
            const ok = await sendRequest('changeDeck', { cards: cardIds, deck: deckName });
            return ok === true;
        }
        catch (err) {
            new obsidian.Notice(`Failed to move card(s): ${err}`);
            console.error(err);
            return false;
        }
    }
    async fetchCardInfo(cardIds) {
        try {
            return await sendRequest('cardsInfo', { cards: cardIds });
        }
        catch (err) {
            new obsidian.Notice(`cardsInfo error: ${err}`);
            console.error(err);
            return [];
        }
    }
    async storeMedia(filename, path) {
        try {
            const result = await sendRequest('storeMediaFile', { filename, path });
            return typeof result === 'string' ? result : filename;
        }
        catch (err) {
            new obsidian.Notice(`Failed to store media "${filename}": ${err}`);
            console.error(err);
            return null;
        }
    }
    resolveAbsolutePath(vaultPath) {
        const file = this.app.vault.getAbstractFileByPath(vaultPath);
        if (file instanceof obsidian.TFile) {
            // @ts-ignore
            return this.app.vault.adapter.getFullPath(file.path);
        }
        console.warn(`File not found in vault: ${vaultPath}`);
        return null;
    }
}

// Regex-Templates
const DECK_TAG = /#anki\/([^\s]+)/;
const NOTE_ID_COMMENT = /<!--ANKI_NOTE_ID:(\d+)-->/;
const NOTE_ID_COMMENT_GLOBAL = /<!--ANKI_NOTE_ID:(\d+)-->/g;
const IMAGE_EMBED = /!\[\[([^|\]\n]+)(?:\|(\d+))?\]\]/g;
const BLOCK_LATEX = /\$\$([\s\S]*?)\$\$/g;
const INLINE_LATEX = /(?<![\$\\])\$([^$]+?)(?<!\\)\$/g;
const DEFAULT_MODEL = 'Basic';
class SimpleAnkiSyncPlugin extends obsidian.Plugin {
    async onload() {
        console.log('Loading Simple Anki Sync Plugin');
        this.anki = new AnkiService(this.app);
        this.addCommand({
            id: 'sync-current-file-with-anki',
            name: 'Sync current file with Anki',
            checkCallback: (checking) => {
                const view = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
                if (view === null || view === void 0 ? void 0 : view.file) {
                    if (!checking)
                        this.syncFile(view.file);
                    return true;
                }
                return false;
            },
        });
        this.addCommand({
            id: 'sync-vault-with-anki',
            name: 'Sync entire vault with Anki',
            callback: async () => {
                await this.syncVault();
            },
        });
    }
    onunload() {
        console.log('Unloading Simple Anki Sync Plugin');
    }
    splitTableRow(row) {
        const clean = row.trim().replace(/^\||\|$/g, '');
        const cells = [];
        let buf = '';
        for (let i = 0; i < clean.length; i++) {
            const ch = clean[i];
            if (ch === '\\' && i + 1 < clean.length && clean[i + 1] === '|') {
                buf += '|';
                i++;
            }
            else if (ch === '|') {
                cells.push(buf.trim());
                buf = '';
            }
            else {
                buf += ch;
            }
        }
        cells.push(buf.trim());
        return cells.filter((c) => c !== '' || cells.length === 1);
    }
    parseNotesFromContent(content, file) {
        var _a;
        const tagMatch = content.match(DECK_TAG);
        const raw = (_a = tagMatch === null || tagMatch === void 0 ? void 0 : tagMatch[1]) !== null && _a !== void 0 ? _a : null;
        const deckName = raw ? raw.replace(/\//g, '::') : null;
        const notes = [];
        const lines = content.split('\n');
        for (let i = 0; i < lines.length - 2; i++) {
            const [h, sep, d] = [lines[i], lines[i + 1], lines[i + 2]];
            if (h.trim().startsWith('|') &&
                sep.match(/^\|\s*-{3,}\s*\|$/) &&
                d.trim().startsWith('|')) {
                const front = this.splitTableRow(h)[0];
                const back = this.splitTableRow(d)[0];
                let existingId;
                let endLine = i + 2;
                const next = lines[i + 3];
                const idMatch = next === null || next === void 0 ? void 0 : next.match(NOTE_ID_COMMENT);
                if (idMatch) {
                    existingId = parseInt(idMatch[1], 10);
                    endLine = i + 3;
                }
                notes.push({
                    sourceId: `${file.path}-${i}`,
                    front,
                    back,
                    noteId: existingId,
                    startLine: i,
                    endLine,
                });
                i = endLine;
            }
        }
        return { notes, deckName };
    }
    async processMedia(text, file) {
        let out = text;
        const uploads = [];
        const matches = Array.from(text.matchAll(IMAGE_EMBED));
        for (const m of matches) {
            const [md, path, size] = m;
            const tF = this.app.vault.getAbstractFileByPath(path);
            if (tF instanceof obsidian.TFile) {
                const abs = this.anki.resolveAbsolutePath(path);
                if (abs) {
                    uploads.push({ filePath: abs, ankiFileName: tF.name });
                    const tag = size
                        ? `<img src="${tF.name}" width="${size}">`
                        : `<img src="${tF.name}">`;
                    out = out.replace(md, tag);
                }
            }
        }
        return { content: out, mediaToUpload: uploads };
    }
    convertLatexDelimiters(text) {
        let tmp = text.replace(BLOCK_LATEX, '\\[$1\\]');
        return tmp.replace(INLINE_LATEX, '\\($1\\)');
    }
    async syncFile(file, silent = false) {
        var _a;
        // Check AnkiConnect availability before syncing
        if (!(await this.anki.verifyConnection())) {
            new obsidian.Notice('AnkiConnect is not available. Please make sure Anki is running and AnkiConnect is installed.');
            return [];
        }
        if (!silent)
            new obsidian.Notice(`Syncing ${file.basename}…`);
        const orig = await this.app.vault.read(file);
        const { notes, deckName } = this.parseNotesFromContent(orig, file);
        if (!deckName) {
            if (!silent)
                new obsidian.Notice(`No #anki/deck tag found in ${file.basename}. Skipping.`);
            return [];
        }
        await this.anki.createDeck(deckName);
        const existingIds = [];
        for (const m of orig.matchAll(NOTE_ID_COMMENT_GLOBAL))
            existingIds.push(+m[1]);
        const lines = orig.split('\n');
        let offset = 0;
        const newIds = [];
        for (const note of notes) {
            // Media
            const frontMed = await this.processMedia(note.front, file);
            const backMed = await this.processMedia(note.back, file);
            for (const u of [...frontMed.mediaToUpload, ...backMed.mediaToUpload]) {
                await this.anki.storeMedia(u.ankiFileName, u.filePath);
            }
            // LaTeX
            let frontHtml = this.convertLatexDelimiters(frontMed.content);
            let backHtml = this.convertLatexDelimiters(backMed.content);
            // Obsidian-Link
            const vault = this.app.vault.getName();
            const url = `obsidian://open?vault=${encodeURIComponent(vault)}&file=${encodeURIComponent(file.path)}`;
            backHtml += `<br><small><a href="${url}" style="text-decoration:none;color:grey;font-size:0.8em;">Obsidian Note</a></small>`;
            const fields = { Front: frontHtml, Back: backHtml };
            if (note.noteId) {
                await this.anki.updateNote(note.noteId, fields);
                newIds.push(note.noteId);
                const info = await this.anki.fetchCardInfo([note.noteId]);
                if (((_a = info[0]) === null || _a === void 0 ? void 0 : _a.deckName) !== deckName) {
                    await this.anki.changeDeck([note.noteId], deckName);
                }
            }
            else {
                const created = await this.anki.addNote(deckName, DEFAULT_MODEL, fields);
                if (created) {
                    newIds.push(created);
                    lines.splice(note.endLine + 1 + offset, 0, `<!--ANKI_NOTE_ID:${created}-->`);
                    offset++;
                }
            }
        }
        const updated = lines.join('\n');
        if (updated !== orig) {
            await this.app.vault.modify(file, updated);
        }
        if (!silent)
            new obsidian.Notice(`${file.basename} synced.`);
        return newIds;
    }
    async syncVault() {
        // Check AnkiConnect availability before vault sync
        if (!(await this.anki.verifyConnection())) {
            new obsidian.Notice('AnkiConnect is not available. Please make sure Anki is running and AnkiConnect is installed.');
            return;
        }
        new obsidian.Notice('Starting vault sync. This may take a while…');
        const files = this.app.vault.getMarkdownFiles();
        for (const f of files) {
            try {
                await this.syncFile(f, true);
            }
            catch (e) {
                console.error(`Error in vault sync for ${f.path}:`, e);
                new obsidian.Notice(`Error syncing ${f.basename}. See console for Details.`);
            }
        }
        new obsidian.Notice('Vault sync complete.');
    }
}

module.exports = SimpleAnkiSyncPlugin;
//# sourceMappingURL=main.js.map
