/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, please visit the GitHub repository of this plugin
*/

'use strict';

var obsidian = require('obsidian');

const ANKI_CONNECT_URL = 'http://127.0.0.1:8765';
const MANAGED_NOTE_TAG = 'obsidian_simple_anki_sync_created';
async function sendRequest(action, params = {}) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.addEventListener('error', () => reject(new Error('Failed to issue request to AnkiConnect. Is Anki running?')));
        xhr.addEventListener('load', () => {
            try {
                const resp = JSON.parse(xhr.responseText);
                if (resp.error) {
                    console.error('AnkiConnect Error:', resp.error);
                    reject(new Error(`AnkiConnect error: ${resp.error}`));
                }
                else {
                    resolve(resp.result);
                }
            }
            catch (err) {
                console.error('Failed to parse AnkiConnect response:', err);
                reject(new Error('Failed to parse AnkiConnect response.'));
            }
        });
        xhr.open('POST', ANKI_CONNECT_URL);
        xhr.send(JSON.stringify({ action, version: 6, params }));
    });
}
class AnkiService {
    constructor(app) {
        this.app = app;
    }
    async verifyConnection() {
        try {
            await sendRequest('requestPermission');
            const decks = await sendRequest('deckNames');
            return Array.isArray(decks);
        }
        catch (err) {
            new obsidian.Notice('AnkiConnect connection failed. Is Anki open with AnkiConnect installed?');
            console.error('verifyConnection error:', err);
            return false;
        }
    }
    async fetchDecks() {
        try {
            return await sendRequest('deckNames');
        }
        catch (err) {
            new obsidian.Notice('Failed to retrieve deck list from Anki.');
            console.error(err);
            return [];
        }
    }
    async createDeck(name) {
        try {
            await sendRequest('createDeck', { deck: name });
        }
        catch (err) {
            if (err instanceof Error && err.message.includes('deck already exists'))
                return;
            new obsidian.Notice(`Could not create deck "${name}".`);
            console.error(err);
        }
    }
    async addNote(deck, model, fields, tags = []) {
        try {
            const allTags = [...tags, MANAGED_NOTE_TAG];
            const result = await sendRequest('addNote', {
                note: { deckName: deck, modelName: model, fields, tags: allTags },
            });
            if (typeof result === 'number')
                return result;
            new obsidian.Notice('AnkiConnect did not return a valid note ID.');
            return null;
        }
        catch (err) {
            new obsidian.Notice(`Failed to add note: ${err instanceof Error ? err.message : err}`);
            console.error(err);
            return null;
        }
    }
    async updateNote(noteId, fields) {
        try {
            await sendRequest('updateNoteFields', {
                note: { id: noteId, fields },
            });
            // Ensure our tag persists
            const infos = await this.fetchNotesInfo([noteId]);
            if (infos[0] && !infos[0].tags.includes(MANAGED_NOTE_TAG)) {
                await sendRequest('updateNoteTags', {
                    note: noteId,
                    tags: [...infos[0].tags, MANAGED_NOTE_TAG],
                });
            }
        }
        catch (err) {
            new obsidian.Notice(`Failed to update note ${noteId}: ${err}`);
            console.error(err);
        }
    }
    async deleteNotes(ids) {
        if (!ids.length)
            return;
        try {
            await sendRequest('deleteNotes', { notes: ids });
            new obsidian.Notice(`Deleted ${ids.length} note(s) from Anki.`);
        }
        catch (err) {
            new obsidian.Notice(`Could not delete notes: ${err}`);
            console.error(err);
        }
    }
    async fetchNotesInfo(ids) {
        if (!ids.length)
            return [];
        try {
            return await sendRequest('notesInfo', { notes: ids });
        }
        catch (err) {
            new obsidian.Notice('Failed to fetch note info from Anki.');
            console.error(err);
            return [];
        }
    }
    async findManagedNotes() {
        try {
            const result = await sendRequest('findNotes', { query: `tag:${MANAGED_NOTE_TAG}` });
            return Array.isArray(result) ? result : [];
        }
        catch (err) {
            new obsidian.Notice('Could not find managed notes in Anki.');
            console.error(err);
            return [];
        }
    }
    async changeDeck(cardIds, deckName) {
        try {
            const ok = await sendRequest('changeDeck', { cards: cardIds, deck: deckName });
            return ok === true;
        }
        catch (err) {
            new obsidian.Notice(`Failed to move card(s): ${err}`);
            console.error(err);
            return false;
        }
    }
    async fetchCardInfo(cardIds) {
        try {
            return await sendRequest('cardsInfo', { cards: cardIds });
        }
        catch (err) {
            new obsidian.Notice(`cardsInfo error: ${err}`);
            console.error(err);
            return [];
        }
    }
    async storeMediaBase64(filename, data) {
        try {
            const result = await sendRequest('storeMediaFile', {
                filename,
                data, // the base64 payload
            });
            return typeof result === 'string' ? result : filename;
        }
        catch (err) {
            new obsidian.Notice(`Failed to store media "${filename}": ${err}`);
            console.error(err);
            return null;
        }
    }
    resolveAbsolutePath(vaultPath) {
        const file = this.app.vault.getAbstractFileByPath(vaultPath);
        if (file instanceof obsidian.TFile) {
            // @ts-ignore
            return this.app.vault.adapter.getFullPath(file.path);
        }
        console.warn(`File not found in vault: ${vaultPath}`);
        return null;
    }
}

// Regex-Templates
const DECK_TAG = /#anki\/([^\s]+)/;
const NOTE_ID_COMMENT = /<!--ANKI_NOTE_ID:(\d+)-->/;
const NOTE_ID_COMMENT_GLOBAL = /<!--ANKI_NOTE_ID:(\d+)-->/g;
const IMAGE_EMBED = /!\[\[([^|\]\n]+)(?:\|(\d+))?\]\]/g;
const BLOCK_LATEX = /\$\$([\s\S]*?)\$\$/g;
const INLINE_LATEX = /(?<![\$\\])\$([^$]+?)(?<!\\)\$/g;
const DEFAULT_MODEL = 'Basic';
class SimpleAnkiSyncPlugin extends obsidian.Plugin {
    async onload() {
        console.log('Loading Simple Anki Sync Plugin');
        this.anki = new AnkiService(this.app);
        this.addCommand({
            id: 'sync-current-file-with-anki',
            name: 'Sync current file with Anki',
            checkCallback: (checking) => {
                const view = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
                if (view === null || view === void 0 ? void 0 : view.file) {
                    if (!checking)
                        this.syncFile(view.file);
                    return true;
                }
                return false;
            },
        });
        this.addCommand({
            id: 'sync-vault-with-anki',
            name: 'Sync entire vault with Anki',
            callback: async () => {
                await this.syncVault();
            },
        });
    }
    onunload() {
        console.log('Unloading Simple Anki Sync Plugin');
    }
    // Splits a table row into its cells
    splitTableRow(row) {
        const clean = row.trim().replace(/^\||\|$/g, '');
        const cells = [];
        let buf = '';
        let inBrackets = false; // [[…]]
        let inInlineMath = false; // $…$
        let inBlockMath = false; // $$…$$
        for (let i = 0; i < clean.length; i++) {
            if (!inInlineMath && clean.slice(i, i + 2) === '$$') {
                inBlockMath = !inBlockMath;
                buf += '$$';
                i++;
                continue;
            }
            if (!inBlockMath && clean[i] === '$') {
                inInlineMath = !inInlineMath;
                buf += '$';
                continue;
            }
            if (!inBrackets && clean.slice(i, i + 2) === '[[') {
                inBrackets = true;
                buf += '[[';
                i++;
                continue;
            }
            if (inBrackets && clean.slice(i, i + 2) === ']]') {
                inBrackets = false;
                buf += ']]';
                i++;
                continue;
            }
            const ch = clean[i];
            if (ch === '\\' && clean[i + 1] === '|') {
                buf += '|';
                i++;
                continue;
            }
            if (ch === '|' && !inBrackets && !inInlineMath && !inBlockMath) {
                cells.push(buf.trim());
                buf = '';
                continue;
            }
            buf += ch;
        }
        cells.push(buf.trim());
        return cells.filter((c) => c !== '' || cells.length === 1);
    }
    // Parses the content of a file and extracts notes and deck name
    parseNotesFromContent(content, file) {
        var _a, _b;
        const tagMatch = content.match(DECK_TAG);
        const deckName = (_b = (_a = tagMatch === null || tagMatch === void 0 ? void 0 : tagMatch[1]) === null || _a === void 0 ? void 0 : _a.replace(/\//g, '::')) !== null && _b !== void 0 ? _b : null;
        const notes = [];
        const lines = content.split('\n');
        for (let i = 0; i < lines.length - 2; i++) {
            const h = lines[i];
            const sep = lines[i + 1];
            const d = lines[i + 2];
            if (h.trim().startsWith('|') &&
                sep.match(/^\|\s*-{3,}\s*\|$/) &&
                d.trim().startsWith('|')) {
                const headerCells = this.splitTableRow(h);
                const dataCells = this.splitTableRow(d);
                if (headerCells.length !== 1 || dataCells.length !== 1) {
                    i++;
                    continue;
                }
                const nextLine = lines[i + 3];
                if (nextLine === null || nextLine === void 0 ? void 0 : nextLine.trim().startsWith('|')) {
                    i++;
                    continue;
                }
                let existingId;
                let endLine = i + 2;
                const maybeComment = lines[i + 3];
                const idMatch = maybeComment === null || maybeComment === void 0 ? void 0 : maybeComment.match(NOTE_ID_COMMENT);
                if (idMatch) {
                    existingId = parseInt(idMatch[1], 10);
                    endLine = i + 3;
                }
                notes.push({
                    sourceId: `${file.path}-${i}`,
                    front: headerCells[0],
                    back: dataCells[0],
                    noteId: existingId,
                    startLine: i,
                    endLine,
                });
                i = endLine;
            }
        }
        return { notes, deckName };
    }
    async processMedia(text, file) {
        let out = text;
        const uploads = [];
        const matches = Array.from(text.matchAll(IMAGE_EMBED));
        for (const m of matches) {
            const [md, linkPath, size] = m;
            const imageFile = this.app.metadataCache.getFirstLinkpathDest(linkPath, file.path);
            if (!(imageFile instanceof obsidian.TFile))
                continue;
            const buffer = await this.app.vault.readBinary(imageFile);
            const dataBase64 = Buffer.from(buffer).toString('base64');
            uploads.push({
                ankiFileName: imageFile.name,
                dataBase64,
            });
            const tag = size
                ? `<img src="${imageFile.name}" width="${size}">`
                : `<img src="${imageFile.name}">`;
            out = out.replace(md, tag);
        }
        return { content: out, mediaToUpload: uploads };
    }
    convertLatexDelimiters(text) {
        let tmp = text.replace(BLOCK_LATEX, '\\[$1\\]');
        return tmp.replace(INLINE_LATEX, '\\($1\\)');
    }
    async syncFile(file, silent = false) {
        var _a;
        // Check AnkiConnect availability before syncing
        if (!(await this.anki.verifyConnection())) {
            new obsidian.Notice('AnkiConnect is not available. Please make sure Anki is running and AnkiConnect is installed.');
            return [];
        }
        if (!silent)
            new obsidian.Notice(`Syncing ${file.basename}…`);
        const orig = await this.app.vault.read(file);
        const { notes, deckName } = this.parseNotesFromContent(orig, file);
        if (!deckName) {
            if (!silent)
                new obsidian.Notice(`No #anki/deck tag found in ${file.basename}. Skipping.`);
            return [];
        }
        await this.anki.createDeck(deckName);
        const existingIds = [];
        for (const m of orig.matchAll(NOTE_ID_COMMENT_GLOBAL))
            existingIds.push(+m[1]);
        const lines = orig.split('\n');
        let offset = 0;
        const newIds = [];
        for (const note of notes) {
            // Media
            const frontMed = await this.processMedia(note.front, file);
            const backMed = await this.processMedia(note.back, file);
            for (const u of [...frontMed.mediaToUpload, ...backMed.mediaToUpload]) {
                await this.anki.storeMediaBase64(u.ankiFileName, u.dataBase64);
            }
            // LaTeX
            let frontHtml = this.convertLatexDelimiters(frontMed.content);
            let backHtml = this.convertLatexDelimiters(backMed.content);
            // Obsidian-Link
            const vault = this.app.vault.getName();
            const url = `obsidian://open?vault=${encodeURIComponent(vault)}&file=${encodeURIComponent(file.path)}`;
            backHtml += `<br><small><a href="${url}" style="text-decoration:none;color:grey;font-size:0.8em;">Obsidian Note</a></small>`;
            const fields = { Front: frontHtml, Back: backHtml };
            if (note.noteId) {
                await this.anki.updateNote(note.noteId, fields);
                newIds.push(note.noteId);
                const info = await this.anki.fetchCardInfo([note.noteId]);
                if (((_a = info[0]) === null || _a === void 0 ? void 0 : _a.deckName) !== deckName) {
                    await this.anki.changeDeck([note.noteId], deckName);
                }
            }
            else {
                const created = await this.anki.addNote(deckName, DEFAULT_MODEL, fields);
                if (created) {
                    newIds.push(created);
                    lines.splice(note.endLine + 1 + offset, 0, `<!--ANKI_NOTE_ID:${created}-->`);
                    offset++;
                }
            }
        }
        // Remove old IDs and Anki-Cards
        const toDelete = existingIds.filter(id => !newIds.includes(id));
        if (toDelete.length) {
            await this.anki.deleteNotes(toDelete);
            for (const id of toDelete) {
                const commentLine = `<!--ANKI_NOTE_ID:${id}-->`;
                const idx = lines.findIndex(l => l.trim() === commentLine);
                if (idx !== -1) {
                    lines.splice(idx, 1);
                    if (idx < notes.length)
                        offset--;
                }
            }
        }
        const updated = lines.join('\n');
        if (updated !== orig) {
            await this.app.vault.modify(file, updated);
        }
        if (!silent)
            new obsidian.Notice(`${file.basename} synced.`);
        return newIds;
    }
    async syncVault() {
        // Check AnkiConnect availability before vault sync
        if (!(await this.anki.verifyConnection())) {
            new obsidian.Notice('AnkiConnect is not available. Please make sure Anki is running and AnkiConnect is installed.');
            return;
        }
        new obsidian.Notice('Starting vault sync. This may take a while…');
        const files = this.app.vault.getMarkdownFiles();
        for (const f of files) {
            try {
                await this.syncFile(f, true);
            }
            catch (e) {
                console.error(`Error in vault sync for ${f.path}:`, e);
                new obsidian.Notice(`Error syncing ${f.basename}. See console for Details.`);
            }
        }
        new obsidian.Notice('Vault sync complete.');
    }
}

module.exports = SimpleAnkiSyncPlugin;
//# sourceMappingURL=main.js.map
